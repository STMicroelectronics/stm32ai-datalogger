<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AILogging Code Documentation: ai_logging.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AILogging Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ai__logging_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ai_logging.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>: AILogging C implementation  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ai__logging_8h_source.html">ai_logging.h</a>&quot;</code><br />
</div>
<p><a href="ai__logging_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7aed73681ceecd414d2550e8298ec150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a7aed73681ceecd414d2550e8298ec150">ai_logging_init</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device)</td></tr>
<tr class="separator:a7aed73681ceecd414d2550e8298ec150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00c5e1bda4bedceaa995ba3811585cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#ad00c5e1bda4bedceaa995ba3811585cc">ai_logging_init_send</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t(*send_fptr)(uint8_t *data_ptr, uint32_t data_size), uint8_t *send_buffer, uint32_t send_buffer_max_size)</td></tr>
<tr class="separator:ad00c5e1bda4bedceaa995ba3811585cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bac5d4c35f783ce7ee27883f744be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#ad7bac5d4c35f783ce7ee27883f744be2">ai_logging_init_send_ctx</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t(*send_ctx_fptr)(void *ctx, uint8_t *data_ptr, uint32_t data_size), void *ctx, uint8_t *send_buffer, uint32_t send_buffer_max_size)</td></tr>
<tr class="separator:ad7bac5d4c35f783ce7ee27883f744be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179d3c93ac5d17ab62f9eecc3be52517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a179d3c93ac5d17ab62f9eecc3be52517">ai_logging_init_receive</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t(*receive_fptr)(uint8_t *data_ptr, uint32_t data_size), uint32_t receive_fptr_size_to_read, uint8_t *receive_buffer, uint32_t receive_buffer_max_size)</td></tr>
<tr class="separator:a179d3c93ac5d17ab62f9eecc3be52517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abacbd0adaf3edb06a7b3fa5e47a0c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a6abacbd0adaf3edb06a7b3fa5e47a0c9">ai_logging_init_receive_ctx</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t(*receive_ctx_fptr)(void *ctx, uint8_t *data_ptr, uint32_t data_size), void *ctx, uint32_t receive_fptr_size_to_read, uint8_t *receive_buffer, uint32_t receive_buffer_max_size)</td></tr>
<tr class="separator:a6abacbd0adaf3edb06a7b3fa5e47a0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e63305c20b40c089c86290c2f6c909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#af2e63305c20b40c089c86290c2f6c909">ai_logging_init_raw_data_buffer</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t *user_raw_buffer)</td></tr>
<tr class="separator:af2e63305c20b40c089c86290c2f6c909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857262e4eb34b6cd0f5fe6341c4fb550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a857262e4eb34b6cd0f5fe6341c4fb550">ai_logging_send_data</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> data, <a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a> data_info)</td></tr>
<tr class="separator:a857262e4eb34b6cd0f5fe6341c4fb550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1ee4c06d50bee56fbcfec945b1dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#ab3f1ee4c06d50bee56fbcfec945b1dfc">ai_logging_send_message</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__message.html">ai_logging_message</a> message)</td></tr>
<tr class="separator:ab3f1ee4c06d50bee56fbcfec945b1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51637e0f5e93422591232dc0651da44f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a51637e0f5e93422591232dc0651da44f">ai_logging_send_message_with_data</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__message.html">ai_logging_message</a> message, <a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> data, <a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a> data_info)</td></tr>
<tr class="separator:a51637e0f5e93422591232dc0651da44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460511d0b4da4db5588aa41fa8f6fead"><td class="memItemLeft" align="right" valign="top"><a id="a460511d0b4da4db5588aa41fa8f6fead"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a460511d0b4da4db5588aa41fa8f6fead">_ai_logging_prepare_raw_header_in_buffer</a> (uint8_t *buffer, uint8_t data_type, uint32_t total_data_length)</td></tr>
<tr class="memdesc:a460511d0b4da4db5588aa41fa8f6fead"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function put the header of a raw packet at the specified buffer <br /></td></tr>
<tr class="separator:a460511d0b4da4db5588aa41fa8f6fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c4e5a93787fe1ce1a400290bbb49c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a5e0c4e5a93787fe1ce1a400290bbb49c">ai_logging_send_header_for_raw_data</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t data_type, uint32_t total_data_length)</td></tr>
<tr class="separator:a5e0c4e5a93787fe1ce1a400290bbb49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcf6ca1e364aeba05b4e30e7697345f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#afbcf6ca1e364aeba05b4e30e7697345f">ai_logging_send_raw_data</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t *buffer, uint32_t buffer_length)</td></tr>
<tr class="separator:afbcf6ca1e364aeba05b4e30e7697345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf94df31546df2b8acf827c2b08136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a41cf94df31546df2b8acf827c2b08136">ai_logging_purge</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t size)</td></tr>
<tr class="separator:a41cf94df31546df2b8acf827c2b08136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc62f604bf60a4546927bd9d25dfd75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#adc62f604bf60a4546927bd9d25dfd75e">ai_logging_data_received_callback</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t *data_ptr, uint32_t data_size)</td></tr>
<tr class="separator:adc62f604bf60a4546927bd9d25dfd75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a79c6d627a21ab32e190f1bd8577b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a217a79c6d627a21ab32e190f1bd8577b">ai_logging_wait_for_data</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet)</td></tr>
<tr class="separator:a217a79c6d627a21ab32e190f1bd8577b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf1eed6e2949cc9782d663954fb9399"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#afdf1eed6e2949cc9782d663954fb9399">ai_logging_check_for_received_packet</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet)</td></tr>
<tr class="separator:afdf1eed6e2949cc9782d663954fb9399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c28578ea6836f8e39820663360824a1"><td class="memItemLeft" align="right" valign="top"><a id="a3c28578ea6836f8e39820663360824a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_decode_v1_packet</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet, int32_t start_byte_index)</td></tr>
<tr class="separator:a3c28578ea6836f8e39820663360824a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c0f19344956493ffc387ca3c964b8"><td class="memItemLeft" align="right" valign="top"><a id="a9c5c0f19344956493ffc387ca3c964b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_decode_v2_packet</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet, int32_t start_byte_index)</td></tr>
<tr class="separator:a9c5c0f19344956493ffc387ca3c964b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d87666f3c857e9f3c383b61ff3253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a0f1d87666f3c857e9f3c383b61ff3253">ai_logging_prepare_next_packet</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device)</td></tr>
<tr class="separator:a0f1d87666f3c857e9f3c383b61ff3253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386fea29296897d636da64e933ef1edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a386fea29296897d636da64e933ef1edc">ai_logging_send_packet</a> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet)</td></tr>
<tr class="separator:a386fea29296897d636da64e933ef1edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f6ffaf9e3402de87a2ceb24edc19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#abe9f6ffaf9e3402de87a2ceb24edc19c">ai_logging_clear_packet</a> (<a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *packet)</td></tr>
<tr class="separator:abe9f6ffaf9e3402de87a2ceb24edc19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495fd0e61bb3cf60b0ada6d7c834601c"><td class="memItemLeft" align="right" valign="top"><a id="a495fd0e61bb3cf60b0ada6d7c834601c"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_find_start_byte</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t from)</td></tr>
<tr class="separator:a495fd0e61bb3cf60b0ada6d7c834601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef97154710fd2f1316b7366edbd54bf"><td class="memItemLeft" align="right" valign="top"><a id="a4ef97154710fd2f1316b7366edbd54bf"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_is_there_packet_type_v1</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t at)</td></tr>
<tr class="separator:a4ef97154710fd2f1316b7366edbd54bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36782b3d528f5322022230e96556dcd1"><td class="memItemLeft" align="right" valign="top"><a id="a36782b3d528f5322022230e96556dcd1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_is_there_packet_type_v2</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint32_t at)</td></tr>
<tr class="separator:a36782b3d528f5322022230e96556dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d067c5dde0f2398e86ddb603a28d4f7"><td class="memItemLeft" align="right" valign="top"><a id="a7d067c5dde0f2398e86ddb603a28d4f7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_uint32_from_buffer</b> (uint8_t *buffer, uint32_t shift, uint32_t *data_out)</td></tr>
<tr class="separator:a7d067c5dde0f2398e86ddb603a28d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2840ab6bfc39446418145d02230516"><td class="memItemLeft" align="right" valign="top"><a id="a9e2840ab6bfc39446418145d02230516"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_int32_from_buffer</b> (uint8_t *buffer, uint32_t shift, int32_t *data_out)</td></tr>
<tr class="separator:a9e2840ab6bfc39446418145d02230516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f591ce85352a9c96b0f1a0edfda7c38"><td class="memItemLeft" align="right" valign="top"><a id="a5f591ce85352a9c96b0f1a0edfda7c38"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_uint16_from_buffer</b> (uint8_t *buffer, uint32_t shift, uint16_t *data_out)</td></tr>
<tr class="separator:a5f591ce85352a9c96b0f1a0edfda7c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916e457b78b2fd0ca43cda07a1d82183"><td class="memItemLeft" align="right" valign="top"><a id="a916e457b78b2fd0ca43cda07a1d82183"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_uint8_from_buffer</b> (uint8_t *buffer, uint32_t shift, uint8_t *data_out)</td></tr>
<tr class="separator:a916e457b78b2fd0ca43cda07a1d82183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cba8b94f14c888f1ea1e090b29e948"><td class="memItemLeft" align="right" valign="top"><a id="a73cba8b94f14c888f1ea1e090b29e948"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_ai_logging_fire_error</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device)</td></tr>
<tr class="separator:a73cba8b94f14c888f1ea1e090b29e948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f95c211145096c6819878fdbbcd5d7"><td class="memItemLeft" align="right" valign="top"><a id="ac4f95c211145096c6819878fdbbcd5d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_ai_logging_call_send_fptr</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t *data_ptr, uint32_t data_size)</td></tr>
<tr class="separator:ac4f95c211145096c6819878fdbbcd5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796688cfcebe4a2d55375c9452f1960b"><td class="memItemLeft" align="right" valign="top"><a id="a796688cfcebe4a2d55375c9452f1960b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_data_to_buffer</b> (<a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *device, uint8_t *data_ptr, uint16_t size)</td></tr>
<tr class="separator:a796688cfcebe4a2d55375c9452f1960b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee01f051d23a73c1920ed7a3fd406cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#aee01f051d23a73c1920ed7a3fd406cc0">ai_logging_create_shape_0d</a> (<a class="el" href="structai__logging__shape.html">ai_logging_shape</a> *shape)</td></tr>
<tr class="separator:aee01f051d23a73c1920ed7a3fd406cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a556eb8206efea760b0a710a7f505"><td class="memItemLeft" align="right" valign="top"><a id="afb7a556eb8206efea760b0a710a7f505"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_create_shape_1d</b> (<a class="el" href="structai__logging__shape.html">ai_logging_shape</a> *shape, uint16_t dim_x)</td></tr>
<tr class="separator:afb7a556eb8206efea760b0a710a7f505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1121a16a7dc5b132068485a8dd85302"><td class="memItemLeft" align="right" valign="top"><a id="ad1121a16a7dc5b132068485a8dd85302"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_create_shape_2d</b> (<a class="el" href="structai__logging__shape.html">ai_logging_shape</a> *shape, uint16_t dim_x, uint16_t dim_y)</td></tr>
<tr class="separator:ad1121a16a7dc5b132068485a8dd85302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662504e1bcce3276cb2998f6c958cde5"><td class="memItemLeft" align="right" valign="top"><a id="a662504e1bcce3276cb2998f6c958cde5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ai_logging_create_shape_3d</b> (<a class="el" href="structai__logging__shape.html">ai_logging_shape</a> *shape, uint16_t dim_x, uint16_t dim_y, uint16_t dim_z)</td></tr>
<tr class="separator:a662504e1bcce3276cb2998f6c958cde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0311a137926c24757c398a6b31ac09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structai__logging__message.html">ai_logging_message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a8d0311a137926c24757c398a6b31ac09">create_message</a> (uint8_t *message_buffer, uint8_t message_size)</td></tr>
<tr class="separator:a8d0311a137926c24757c398a6b31ac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac056bc30c34c8eac64ee91daf0c04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ai__logging_8c.html#a1ac056bc30c34c8eac64ee91daf0c04d">create_buffer</a> (uint8_t *buffer, uint32_t buffer_size)</td></tr>
<tr class="separator:a1ac056bc30c34c8eac64ee91daf0c04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>: AILogging C implementation </p>
<p>Copyright (c) 2020-2021 STMicroelectronics. All rights reserved. This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>

<p class="definition">Definition in file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afdf1eed6e2949cc9782d663954fb9399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf1eed6e2949cc9782d663954fb9399">&#9670;&nbsp;</a></span>ai_logging_check_for_received_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai_logging_check_for_received_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to check if a packet has been received. A return value &gt; 0 indicates that a packet is present, other values can indicates an error that you can check using the ai_logging_error enum. If receiving standard packet sent through the standard API, the data received will be located into the library internal buffer, otherwise if using the raw API, the received data will be available into the user reception buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> stucture </td></tr>
    <tr><td class="paramname">packet</td><td>a pointer to an <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> structure that will hold the data received. Values are set only if packet is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the status of the search. ret &gt; 0 indicates that a packet has been found, ret = 0 indicates no packet, ret &lt; 0 indicates an error has been detected. The error can be critical or not. Check the ai_logging_error enum to get more info on errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00394">394</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="abe9f6ffaf9e3402de87a2ceb24edc19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f6ffaf9e3402de87a2ceb24edc19c">&#9670;&nbsp;</a></span>ai_logging_clear_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_clear_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to reset/initialize a packet with a default state. This should be used in first phase to initialize <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> fields. Then it can be used when calling ai_logging_prepare_next_packet to be sure the fields are resetting into the structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>a pointer to the <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00788">788</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="aee01f051d23a73c1920ed7a3fd406cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee01f051d23a73c1920ed7a3fd406cc0">&#9670;&nbsp;</a></span>ai_logging_create_shape_0d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_create_shape_0d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__shape.html">ai_logging_shape</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helpers function that helps you to fill your shape data into <a class="el" href="structai__logging__shape.html">ai_logging_shape</a>. </p>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00911">911</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="adc62f604bf60a4546927bd9d25dfd75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc62f604bf60a4546927bd9d25dfd75e">&#9670;&nbsp;</a></span>ai_logging_data_received_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_data_received_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Useful function that put data into library internal buffers. If user manage himself the data reception, this function should be used to add data into internal buffers. If not using blocking API (ai_logging_wait_for_data), you should use this function. If you use a reception loop and ai_logging_check_for_received_packet, you should use this function. If you are receiving your data through interrupt, you should also you this function. An internal copy of the received data will be done except if using raw api.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">data_ptr</td><td>a pointer to the received data to should be put into the internal buffers </td></tr>
    <tr><td class="paramname">data_size</td><td>the size of the received data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00321">321</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a7aed73681ceecd414d2550e8298ec150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aed73681ceecd414d2550e8298ec150">&#9670;&nbsp;</a></span>ai_logging_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> instances with default (resetted) values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00023">23</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="af2e63305c20b40c089c86290c2f6c909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e63305c20b40c089c86290c2f6c909">&#9670;&nbsp;</a></span>ai_logging_init_raw_data_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init_raw_data_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>user_raw_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer to be used after the first initialize function to initialize the low level reception capabilities. This is used to receive "raw" data without using the standard packet formatting (packet corruption checks are also disabled) Thanks to this function the receive data will directly be put at the address you specify.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">user_raw_buffer</td><td>a pointer to the buffer where you want to receive the data. The buffer size should be large enough. No check are performed when receiving data which can result in memory corruption. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00084">84</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a179d3c93ac5d17ab62f9eecc3be52517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179d3c93ac5d17ab62f9eecc3be52517">&#9670;&nbsp;</a></span>ai_logging_init_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(uint8_t *data_ptr, uint32_t data_size)&#160;</td>
          <td class="paramname"><em>receive_fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>receive_fptr_size_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receive_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>receive_buffer_max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer to be used after the first initialize function to initialize the receive capability. This is used when user want to do synchronous API calls like ai_logging_wait_for_data that will try to read data from the user read function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">receive_fptr</td><td>a pointer to a function that will be used to receive data. This is used when calling the blocking API like the ai_logging_wait_for_data function. If you are not using blocking API, you can pass NULL to this parameter. </td></tr>
    <tr><td class="paramname">receive_fptr_size_to_read</td><td>if receive_fptr is used, this parameter indicates the size that will be used to call the receive_fpt function. </td></tr>
    <tr><td class="paramname">receive_buffer</td><td>the buffer that will be used internally to store and parse received data to decode packets. This buffer should be as big as the maximum data you want to receive + header size (usually 11 bytes are sufficient). </td></tr>
    <tr><td class="paramname">receive_buffer_max_size</td><td>the size of the receive_buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00067">67</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a6abacbd0adaf3edb06a7b3fa5e47a0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abacbd0adaf3edb06a7b3fa5e47a0c9">&#9670;&nbsp;</a></span>ai_logging_init_receive_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init_receive_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(void *ctx, uint8_t *data_ptr, uint32_t data_size)&#160;</td>
          <td class="paramname"><em>receive_ctx_fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>receive_fptr_size_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receive_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>receive_buffer_max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer to be used after the first initialize function to initialize the receive capability. This is used when user want to do synchronous API calls like ai_logging_wait_for_data that will try to read data from the user read function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">receive_ctx_fptr</td><td>a pointer to a function that will be used to receive data. This is used when calling the blocking API like the ai_logging_wait_for_data function. If you are not using blocking API, you can pass NULL to this parameter. The function prototype should also have the ctx parameter which is the context the user want to use. </td></tr>
    <tr><td class="paramname">ctx</td><td>the context to be used when calling the receive function. Can be anything the user wants to have when the receive function is called </td></tr>
    <tr><td class="paramname">receive_fptr_size_to_read</td><td>if receive_fptr is used, this parameter indicates the size that will be used to call the receive_fpt function. </td></tr>
    <tr><td class="paramname">receive_buffer</td><td>the buffer that will be used internally to store and parse received data to decode packets. This buffer should be as big as the maximum data you want to receive + header size (usually 11 bytes are sufficient). </td></tr>
    <tr><td class="paramname">receive_buffer_max_size</td><td>the size of the receive_buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00075">75</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="ad00c5e1bda4bedceaa995ba3811585cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00c5e1bda4bedceaa995ba3811585cc">&#9670;&nbsp;</a></span>ai_logging_init_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(uint8_t *data_ptr, uint32_t data_size)&#160;</td>
          <td class="paramname"><em>send_fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>send_buffer_max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer to be used after the first initialize function to initialize the send capability</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">send_fptr</td><td>a pointer to a function that will be used to send data through the communication interface. Prototype of the function must respect the required prototype. </td></tr>
    <tr><td class="paramname">send_buffer</td><td>a byte buffer that will be used by the API to store data before they are sent. The buffer size should be greater than the size of the packet's header you want to send. Data itself will be send separatly if buffer is too small . </td></tr>
    <tr><td class="paramname">send_buffer_max_size</td><td>the maximum size of the send_buffer buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00052">52</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="ad7bac5d4c35f783ce7ee27883f744be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bac5d4c35f783ce7ee27883f744be2">&#9670;&nbsp;</a></span>ai_logging_init_send_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_init_send_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(void *ctx, uint8_t *data_ptr, uint32_t data_size)&#160;</td>
          <td class="paramname"><em>send_ctx_fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>send_buffer_max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer to be used after the first initialize function to initialize the send capability that is supporting custom user context pointer. The context will be passed to the send and receive function when user wants to send or receive packets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">send_ctx_fptr</td><td>a pointer to a function that will be used to send data through the communication interface. The context of the user is added to this function to be able retrive data when send function is called </td></tr>
    <tr><td class="paramname">ctx</td><td>the context to be used when calling the send function. Can be anything the user wants to have when the send function is called </td></tr>
    <tr><td class="paramname">send_buffer</td><td>a byte buffer that will be used by the API to store data before they are sent. The buffer size should be greater than the size of the packet's header you want to send. Data itself will be send separatly if buffer is too small . </td></tr>
    <tr><td class="paramname">send_buffer_max_size</td><td>the maximum size of the send_buffer buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00059">59</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a0f1d87666f3c857e9f3c383b61ff3253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1d87666f3c857e9f3c383b61ff3253">&#9670;&nbsp;</a></span>ai_logging_prepare_next_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_prepare_next_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function prepare the internal library states to receive a new packet, this function should be called when you no longer need to use the received data. This function should be called before receiving new packets, otherwise buffer overflow could occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00661">661</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a41cf94df31546df2b8acf827c2b08136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cf94df31546df2b8acf827c2b08136">&#9670;&nbsp;</a></span>ai_logging_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_purge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called when transmission problem occurs. If either the data are not sent due to lack of data (waiting data to be filled into buffer), or data are not received due to blocking API (waiting for N bytes to read and unblock). You can call this function to send garbage data to force data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">size</td><td>the size of the garbage data you want to send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00276">276</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a857262e4eb34b6cd0f5fe6341c4fb550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857262e4eb34b6cd0f5fe6341c4fb550">&#9670;&nbsp;</a></span>ai_logging_send_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a>&#160;</td>
          <td class="paramname"><em>data_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a simple data buffer with its associated <a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a> specified which includes shape and type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">data</td><td>an <a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> structure which includes the buffer and its size </td></tr>
    <tr><td class="paramname">data_info</td><td>an <a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a> structure which includes the data type and the data shape </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00089">89</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a5e0c4e5a93787fe1ce1a400290bbb49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0c4e5a93787fe1ce1a400290bbb49c">&#9670;&nbsp;</a></span>ai_logging_send_header_for_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_header_for_raw_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>total_data_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function with ai_logging_send_raw_data is used to send raw data without packet control when receiving. The data type and size must be sent at the beginning with ai_logging_send_header_for_raw_data, then data are sent with ai_logging_send_raw_data. The advantage is that you can send your data piece by piece. You have a low level control on the data. On the reception side, you can directly put the received data into a user buffer (received by the same function as standard packets).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">data_type</td><td>a byte, from 0x00 to 0xC for known types (see ai_logging_payload_type enum) and greater than 0xC for custom data types </td></tr>
    <tr><td class="paramname">total_data_length</td><td>the total length of the data you will send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00243">243</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="ab3f1ee4c06d50bee56fbcfec945b1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f1ee4c06d50bee56fbcfec945b1dfc">&#9670;&nbsp;</a></span>ai_logging_send_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__message.html">ai_logging_message</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a simple message (maximum 255 bytes)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">message</td><td>an <a class="el" href="structai__logging__message.html">ai_logging_message</a> containing the message and its length </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00095">95</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a51637e0f5e93422591232dc0651da44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51637e0f5e93422591232dc0651da44f">&#9670;&nbsp;</a></span>ai_logging_send_message_with_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_message_with_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__message.html">ai_logging_message</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a>&#160;</td>
          <td class="paramname"><em>data_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a message next to data. Message can be used to identify data (string description, channel,...) and transmitted in one packet. This will be received as a single packet with message and data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">message</td><td>an <a class="el" href="structai__logging__message.html">ai_logging_message</a> containing the message and its length </td></tr>
    <tr><td class="paramname">data</td><td>an <a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> structure which includes the buffer and its size </td></tr>
    <tr><td class="paramname">data_info</td><td>an <a class="el" href="structai__logging__tensor.html">ai_logging_tensor</a> structure which includes the data type and the data shape </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00106">106</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a386fea29296897d636da64e933ef1edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386fea29296897d636da64e933ef1edc">&#9670;&nbsp;</a></span>ai_logging_send_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is part of the new API that is able to send directly <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> data. User has to set the data/message/shape/type/... directly in the structure fields and then call ai_logging_send_packet to send the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointerto an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">packet</td><td>a pointer to the packet to be sent with the fiels set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00677">677</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="afbcf6ca1e364aeba05b4e30e7697345f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcf6ca1e364aeba05b4e30e7697345f">&#9670;&nbsp;</a></span>ai_logging_send_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai_logging_send_raw_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function with ai_logging_send_header_for_raw_data is used to send raw data without packet control when receiving. You can call this function as many times as you want to send the data of size total_data_length you specified when calling ai_logging_send_header_for_raw_data. On the reception side, you can directly put the received data into a user buffer (received by the same function as standard packets).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">buffer</td><td>a buffer of data to send </td></tr>
    <tr><td class="paramname">buffer_length</td><td>the size of the buffer you want to send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00269">269</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a217a79c6d627a21ab32e190f1bd8577b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217a79c6d627a21ab32e190f1bd8577b">&#9670;&nbsp;</a></span>ai_logging_wait_for_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai_logging_wait_for_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will wait until a packet is received and will try to read new data thanks to the receive_function (the associated init should be done)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a pointer to an <a class="el" href="structai__logging__device__t.html">ai_logging_device_t</a> structure </td></tr>
    <tr><td class="paramname">packet</td><td>a pointer to an <a class="el" href="structai__logging__packet__t.html">ai_logging_packet_t</a> structure that will hold the data received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>will return the same output as ai_logging_check_for_received_packet. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00360">360</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a1ac056bc30c34c8eac64ee91daf0c04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac056bc30c34c8eac64ee91daf0c04d">&#9670;&nbsp;</a></span>create_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> create_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function creating an <a class="el" href="structai__logging__buffer.html">ai_logging_buffer</a> structure from the parameters specified. You can use this function to help you create needed structure for ai_logging_send_message_with_data function for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer you wantm to use </td></tr>
    <tr><td class="paramname">buffer_size</td><td>the buffer size you want to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a structure initialized with the buffer and buffer_size specified </dd></dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00942">942</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
<a id="a8d0311a137926c24757c398a6b31ac09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0311a137926c24757c398a6b31ac09">&#9670;&nbsp;</a></span>create_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structai__logging__message.html">ai_logging_message</a> create_message </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>message_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function creating an <a class="el" href="structai__logging__message.html">ai_logging_message</a> structure from the parameters specified. You can use this function to help you create needed structure for ai_logging_send_message_with_data function for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message buffer you want to send </td></tr>
    <tr><td class="paramname">message_size</td><td>the site of the message you want to send (up to 255 byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a structure initialized with the message and message_size specified </dd></dl>

<p class="definition">Definition at line <a class="el" href="ai__logging_8c_source.html#l00934">934</a> of file <a class="el" href="ai__logging_8c_source.html">ai_logging.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="ai__logging_8c.html">ai_logging.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
